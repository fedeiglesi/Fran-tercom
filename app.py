# üö® **PROBLEMA DETECTADO: B√∫squeda de ‚Äúcubiertas‚Äù falla**

El bot est√° fallando al buscar ‚Äúcubiertas‚Äù (neum√°ticos). El agente est√° ejecutando `search_products` pero parece no encontrar nada, y luego responde con productos irrelevantes.

-----

## üîç **Diagn√≥stico del problema:**

### **Posibles causas:**

1. **El cat√°logo no tiene la palabra ‚Äúcubierta‚Äù** ‚Üí Usan otro t√©rmino (llanta, neum√°tico, goma, tire, etc.)
1. **La b√∫squeda h√≠brida no est√° matcheando bien**
1. **El agente est√° interpretando mal la tool response**

-----

## üí° **Soluci√≥n: Agregar alias para ‚Äúcubiertas‚Äù**

### **1. Expandir SEARCH_ALIASES:**

```python
SEARCH_ALIASES = {
    "yama": "yamaha", 
    "gilera": "gilera", 
    "zan": "zanella", 
    "hond": "honda",
    "acrilico": "acrilico tablero", 
    "aceite 2t": "aceite pride 2t",
    "aceite 4t": "aceite moto 4t", 
    "aceite moto": "aceite",
    "vc": "VC", 
    "af": "AF", 
    "nsu": "NSU", 
    "gulf": "GULF",
    "yamalube": "YAMALUBE", 
    "suzuki": "suzuki", 
    "zusuki": "suzuki",
    
    # ‚Üê NUEVOS ALIAS PARA CUBIERTAS
    "cubierta": "neumatico llanta goma tire",
    "cubiertas": "neumatico llanta goma tire",
    "neumatico": "cubierta llanta",
    "neumaticos": "cubierta llanta",
    "goma": "cubierta neumatico",
    "gomas": "cubierta neumatico",
    "llanta": "cubierta neumatico",
    "llantas": "cubierta neumatico"
}
```

**Beneficio:** Busca con m√∫ltiples t√©rminos relacionados.

-----

### **2. Verificar qu√© hay en el cat√°logo real:**

Necesitamos saber c√≥mo est√°n etiquetadas las cubiertas en tu CSV. Agreg√° este endpoint temporal:

```python
@app.route("/debug/search/<query>", methods=["GET"])
def debug_search(query: str):
    """Endpoint temporal para debugging de b√∫squedas"""
    catalog, _ = get_catalog_and_index()
    
    # B√∫squeda directa en nombres
    matches = [p for p in catalog if query.lower() in p["name"].lower()]
    
    # B√∫squeda h√≠brida
    hybrid = hybrid_search(query, limit=10)
    
    return jsonify({
        "query": query,
        "direct_matches": len(matches),
        "direct_samples": matches[:5],
        "hybrid_results": [{"name": p["name"], "code": p["code"]} for p in hybrid]
    })
```

**Uso:**

```
https://tu-app.railway.app/debug/search/cubierta
https://tu-app.railway.app/debug/search/neumatico
https://tu-app.railway.app/debug/search/llanta
```

Esto te dir√° exactamente qu√© t√©rminos usa tu CSV.

-----

### **3. Mejorar el prompt del agente:**

```python
system_prompt = """Sos Fran, vendedor de Tercom (mayorista de repuestos de motos en Argentina).

REGLAS CR√çTICAS:
1) Si el usuario env√≠a una LISTA CON CANTIDADES (ej: '10 BUJIA NGK'), ejecut√° quote_bulk_list con todo el texto en este mismo mensaje (no preguntes aclaraciones).
2) Si pide "surtido/b√°sico/cat√°logo", ejecut√° primero search_products.
3) Antes de decir que agregaste algo, ejecut√° add_to_cart. Para ver, us√° view_cart. Para confirmar, confirm_order.
4) Mostr√° precios en ARS formateados y c√≥digos en formato (C√≥d: 1234/12345-123).
5) Respond√© como humano argentino (us√° 'vos', 'dale', 'che', 'mir√°').
6) Nunca digas "te pas√© la lista" sin ejecutar algo real en este turno.
7) **IMPORTANTE: Si el usuario pide "cubiertas/neum√°ticos/llantas", prob√° buscar con diferentes t√©rminos: "cubierta", "neumatico", "llanta", "goma" + modelo de moto.**

T√âRMINOS COMUNES:
- Cubiertas = neum√°ticos = llantas = gomas
- Si no encontr√°s con un t√©rmino, intent√° sin√≥nimos

Formato de productos:
‚Ä¢ **(C√≥d: XXXX/XXXXX-XXX)** Nombre - $precio ARS
Para listas, devolv√© una tabla clara con totales."""
```

-----

### **4. Hacer b√∫squeda multi-t√©rmino autom√°tica:**

```python
def smart_search_with_synonyms(query: str, limit: int = 15):
    """B√∫squeda inteligente que prueba sin√≥nimos autom√°ticamente"""
    
    # Sin√≥nimos conocidos
    synonym_groups = {
        "cubierta": ["cubierta", "neumatico", "llanta", "goma", "tire"],
        "aceite": ["aceite", "lubricante", "oil"],
        "filtro": ["filtro", "filter"],
        "bujia": ["bujia", "spark plug"],
    }
    
    # Detectar si la query tiene un t√©rmino con sin√≥nimos
    query_lower = query.lower()
    queries_to_try = [query]
    
    for main_term, synonyms in synonym_groups.items():
        if main_term in query_lower:
            # Generar queries alternativas
            for syn in synonyms:
                alt_query = query_lower.replace(main_term, syn)
                if alt_query != query_lower:
                    queries_to_try.append(alt_query)
            break
    
    # Ejecutar b√∫squedas y combinar resultados
    all_results = {}
    for q in queries_to_try[:3]:  # M√°ximo 3 variantes
        results = hybrid_search(q, limit=limit)
        for prod in results:
            code = prod["code"]
            if code not in all_results:
                all_results[code] = prod
    
    # Retornar top N √∫nicos
    return list(all_results.values())[:limit]
```

**Uso en ToolExecutor:**

```python
def search_products(self, query: str, limit: int = 15) -> Dict[str, Any]:
    results = smart_search_with_synonyms(query, limit=limit)  # ‚Üê Cambi√° ac√°
    if results:
        save_user_state(self.phone, results[0])
        save_last_search(self.phone, [
            {"code": p["code"], "name": p["name"], "price_ars": p["price_ars"], "price_usd": p["price_usd"], "qty": 1}
            for p in results
        ], query)
    return {
        "success": True,
        "query": query,
        "results": [
            {"code": p["code"], "name": p["name"], "price_ars": p["price_ars"], "price_usd": p["price_usd"], "qty": 1}
            for p in results
        ],
        "count": len(results)
    }
```

-----

## üéØ **Plan de acci√≥n inmediato:**

### **Opci√≥n A: Quick fix (5 minutos)**

1. Agreg√° el endpoint `/debug/search/<query>`
1. Acced√© a `https://tu-app.railway.app/debug/search/cubierta`
1. Mir√° qu√© devuelve
1. Ajust√° `SEARCH_ALIASES` seg√∫n lo que veas
1. Redeploy

### **Opci√≥n B: Fix completo (15 minutos)**

1. Implement√° `smart_search_with_synonyms()`
1. Actualiz√° `search_products()` para usarla
1. Agreg√° los alias de cubiertas
1. Actualiz√° el prompt del agente
1. Redeploy

-----

## üìù **C√≥digo corregido:**

<create_file>
<path>/mnt/user-data/outputs/app_fran_26_fix_cubiertas.py</path>
<description>Fran 2.6 con fix para b√∫squeda de cubiertas/neum√°ticos</description>
<file_text># =========================

# Fran 2.6 - WhatsApp (Railway) - FIX CUBIERTAS

# =========================

import os
import json
import csv
import io
import sqlite3
import logging
import re
import unicodedata
from datetime import datetime, timedelta
from collections import defaultdict
from functools import lru_cache
from contextlib import contextmanager
from time import time
from threading import Lock
from typing import Dict, Any, List, Tuple, Optional
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation

import requests
from flask import Flask, request, jsonify, Response
from twilio.twiml.messaging_response import MessagingResponse
from openai import OpenAI
from rapidfuzz import process, fuzz
import faiss
import numpy as np
from dotenv import load_dotenv

load_dotenv()
app = Flask(**name**)
logging.basicConfig(level=logging.INFO, format=‚Äù%(asctime)s - %(levelname)s - %(message)s‚Äù)
logger = logging.getLogger(‚Äúfran26‚Äù)

OPENAI_API_KEY = (os.environ.get(‚ÄúOPENAI_API_KEY‚Äù) or ‚Äú‚Äù).strip()
if not OPENAI_API_KEY:
raise RuntimeError(‚ÄúFalta OPENAI_API_KEY‚Äù)

CATALOG_URL = (os.environ.get(
‚ÄúCATALOG_URL‚Äù,
‚Äú<https://raw.githubusercontent.com/fedeiglesi/Fran-tercom/main/LISTA_TERCOM_LIMPIA.csv>‚Äù
) or ‚Äú‚Äù).strip()

EXCHANGE_API_URL = (os.environ.get(
‚ÄúEXCHANGE_API_URL‚Äù,
‚Äú<https://dolarapi.com/v1/dolares/oficial>‚Äù
) or ‚Äú‚Äù).strip()

DEFAULT_EXCHANGE = Decimal(os.environ.get(‚ÄúDEFAULT_EXCHANGE‚Äù, ‚Äú1600.0‚Äù))
REQUESTS_TIMEOUT = int(os.environ.get(‚ÄúREQUESTS_TIMEOUT‚Äù, ‚Äú20‚Äù))

TWILIO_ACCOUNT_SID = os.environ.get(‚ÄúTWILIO_ACCOUNT_SID‚Äù, ‚Äú‚Äù)
TWILIO_AUTH_TOKEN = os.environ.get(‚ÄúTWILIO_AUTH_TOKEN‚Äù, ‚Äú‚Äù)
TWILIO_WHATSAPP_FROM = os.environ.get(‚ÄúTWILIO_WHATSAPP_FROM‚Äù, ‚Äú‚Äù)

DB_PATH = os.environ.get(‚ÄúDB_PATH‚Äù, ‚Äútercom.db‚Äù)

try:
from twilio.rest import Client as TwilioClient
from twilio.request_validator import RequestValidator
except Exception:
TwilioClient = None
RequestValidator = None

twilio_rest_available = bool(TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN and TWILIO_WHATSAPP_FROM and TwilioClient)
twilio_rest_client = TwilioClient(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN) if twilio_rest_available else None
twilio_validator = RequestValidator(TWILIO_AUTH_TOKEN) if (RequestValidator and TWILIO_AUTH_TOKEN) else None

client = OpenAI(api_key=OPENAI_API_KEY)

cart_lock = Lock()

@contextmanager
def get_db_connection():
try:
db_dir = os.path.dirname(DB_PATH)
if db_dir and not os.path.exists(db_dir):
os.makedirs(db_dir, exist_ok=True)
except Exception as e:
logger.warning(f‚ÄùNo se pudo crear dir DB: {e}‚Äù)
conn = sqlite3.connect(DB_PATH, timeout=10)
conn.row_factory = sqlite3.Row
try:
yield conn
conn.commit()
except Exception as e:
conn.rollback()
logger.error(f‚ÄùDB error: {e}‚Äù)
raise
finally:
conn.close()

def init_db():
with get_db_connection() as conn:
c = conn.cursor()
try:
c.execute(‚ÄúPRAGMA journal_mode=WAL;‚Äù)
except Exception as e:
logger.warning(f‚ÄùNo se pudo activar WAL: {e}‚Äù)
c.execute(‚ÄúCREATE TABLE IF NOT EXISTS conversations (phone TEXT, message TEXT, role TEXT, timestamp TEXT)‚Äù)
c.execute(‚ÄúCREATE TABLE IF NOT EXISTS carts (phone TEXT, code TEXT, quantity INTEGER, name TEXT, price_ars TEXT, price_usd TEXT, created_at TEXT)‚Äù)
c.execute(‚ÄúCREATE INDEX IF NOT EXISTS idx_conv_phone ON conversations(phone, timestamp DESC)‚Äù)
c.execute(‚ÄúCREATE INDEX IF NOT EXISTS idx_cart_phone ON carts(phone)‚Äù)
c.execute(‚ÄúCREATE TABLE IF NOT EXISTS user_state (phone TEXT PRIMARY KEY, last_code TEXT, last_name TEXT, last_price_ars TEXT, updated_at TEXT)‚Äù)
c.execute(‚ÄúCREATE TABLE IF NOT EXISTS last_search (phone TEXT PRIMARY KEY, products_json TEXT, query TEXT, timestamp TEXT)‚Äù)

init_db()

def save_message(phone: str, msg: str, role: str):
try:
with get_db_connection() as conn:
conn.execute(‚ÄúINSERT INTO conversations VALUES (?, ?, ?, ?)‚Äù, (phone, msg, role, datetime.now().isoformat()))
except Exception as e:
logger.error(f‚ÄùError guardando mensaje: {e}‚Äù)

def get_history_today(phone: str, limit: int = 20):
try:
today_prefix = datetime.now().strftime(‚Äù%Y-%m-%d‚Äù)
with get_db_connection() as conn:
cur = conn.cursor()
cur.execute(‚ÄúSELECT message, role FROM conversations WHERE phone = ? AND substr(timestamp,1,10)=? ORDER BY timestamp ASC LIMIT ?‚Äù, (phone, today_prefix, limit))
return cur.fetchall()
except Exception as e:
logger.error(f‚ÄùError leyendo historial: {e}‚Äù)
return []

def save_user_state(phone: str, prod: Dict[str, Any]):
try:
with get_db_connection() as conn:
conn.execute(
‚ÄúINSERT INTO user_state (phone, last_code, last_name, last_price_ars, updated_at) VALUES (?, ?, ?, ?, ?) ‚Äú
‚ÄúON CONFLICT(phone) DO UPDATE SET last_code=excluded.last_code, last_name=excluded.last_name, last_price_ars=excluded.last_price_ars, updated_at=excluded.updated_at‚Äù,
(phone, prod.get(‚Äúcode‚Äù, ‚Äú‚Äù), prod.get(‚Äúname‚Äù, ‚Äú‚Äù), str(Decimal(str(prod.get(‚Äúprice_ars‚Äù, 0))).quantize(Decimal(‚Äú0.01‚Äù))), datetime.now().isoformat())
)
except Exception as e:
logger.error(f‚ÄùError guardando user_state: {e}‚Äù)

def _coerce_products_serializable(products: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
serializable = []
for p in products:
serializable.append({
‚Äúcode‚Äù: p.get(‚Äúcode‚Äù, ‚Äú‚Äù),
‚Äúname‚Äù: p.get(‚Äúname‚Äù, ‚Äú‚Äù),
‚Äúprice_ars‚Äù: float(p.get(‚Äúprice_ars‚Äù, 0)),
‚Äúprice_usd‚Äù: float(p.get(‚Äúprice_usd‚Äù, 0)),
‚Äúqty‚Äù: int(p.get(‚Äúqty‚Äù, 1))
})
return serializable

def save_last_search(phone: str, products: List[Dict[str, Any]], query: str):
try:
serializable = _coerce_products_serializable(products)
with get_db_connection() as conn:
conn.execute(
‚ÄúINSERT INTO last_search (phone, products_json, query, timestamp) VALUES (?, ?, ?, ?) ‚Äú
‚ÄúON CONFLICT(phone) DO UPDATE SET products_json=excluded.products_json, query=excluded.query, timestamp=excluded.timestamp‚Äù,
(phone, json.dumps(serializable, ensure_ascii=False), query, datetime.now().isoformat())
)
except Exception as e:
logger.error(f‚ÄùError guardando last_search: {e}‚Äù)

def get_last_search(phone: str) -> Optional[Dict[str, Any]]:
try:
with get_db_connection() as conn:
cur = conn.cursor()
cur.execute(‚ÄúSELECT products_json, query, timestamp FROM last_search WHERE phone=?‚Äù, (phone,))
row = cur.fetchone()
if not row:
return None
return {‚Äúproducts‚Äù: json.loads(row[0]), ‚Äúquery‚Äù: row[1], ‚Äútimestamp‚Äù: row[2]}
except Exception as e:
logger.error(f‚ÄùError leyendo last_search: {e}‚Äù)
return None

user_requests = defaultdict(list)
RATE_LIMIT = 15
RATE_WINDOW = 60

def rate_limit_check(phone: str) -> bool:
now = time()
user_requests[phone] = [t for t in user_requests[phone] if now - t < RATE_WINDOW]
if len(user_requests[phone]) >= RATE_LIMIT:
return False
user_requests[phone].append(now)
return True

def strip_accents(s: str) -> str:
if not s:
return ‚Äú‚Äù
return ‚Äú‚Äù.join(ch for ch in unicodedata.normalize(‚ÄúNFKD‚Äù, s) if not unicodedata.combining(ch)).lower()

def to_decimal_money(x) -> Decimal:
try:
s = str(x).replace(‚ÄúUSD‚Äù, ‚Äú‚Äù).replace(‚ÄúARS‚Äù, ‚Äú‚Äù).replace(‚Äù$‚Äù, ‚Äú‚Äù).replace(‚Äù ‚Äú, ‚Äú‚Äù)
if ‚Äú,‚Äù in s and ‚Äú.‚Äù in s:
s = s.replace(‚Äù.‚Äù, ‚Äú‚Äù).replace(‚Äù,‚Äù, ‚Äú.‚Äù)
elif ‚Äú,‚Äù in s:
s = s.replace(‚Äù,‚Äù, ‚Äú.‚Äù)
d = Decimal(s)
except Exception:
d = Decimal(‚Äú0‚Äù)
return d.quantize(Decimal(‚Äú0.01‚Äù), rounding=ROUND_HALF_UP)

def validate_tercom_code(code: str) -> Tuple[bool, str]:
pattern = r‚Äô^\d{4}/\d{5}-\d{3}$‚Äô
s = str(code).strip()
if re.match(pattern, s):
return True, s
code_clean = re.sub(r‚Äô[^0-9]‚Äô, ‚Äò‚Äô, s)
if len(code_clean) == 12:
normalized = f‚Äù{code_clean[:4]}/{code_clean[4:9]}-{code_clean[9:12]}‚Äù
return True, normalized
return False, s

def get_exchange_rate() -> Decimal:
try:
res = requests.get(EXCHANGE_API_URL, timeout=REQUESTS_TIMEOUT)
res.raise_for_status()
venta = res.json().get(‚Äúventa‚Äù, None)
return to_decimal_money(venta) if venta is not None else DEFAULT_EXCHANGE
except Exception as e:
logger.warning(f‚ÄùFallo tasa cambio: {e}‚Äù)
return DEFAULT_EXCHANGE

_catalog_and_index_cache = {‚Äúcatalog‚Äù: None, ‚Äúindex‚Äù: None, ‚Äúbuilt_at‚Äù: None}
_catalog_lock = Lock()

@lru_cache(maxsize=1)
def _load_raw_csv():
r = requests.get(CATALOG_URL, timeout=REQUESTS_TIMEOUT)
r.raise_for_status()
r.encoding = ‚Äúutf-8‚Äù
return r.text

def load_catalog():
try:
text = _load_raw_csv()
reader = csv.reader(io.StringIO(text))
rows = list(reader)
if not rows:
return []
header = [strip_accents(h) for h in rows[0]]
def find_idx(keys):
for i, h in enumerate(header):
if any(k in h for k in keys):
return i
return None
idx_code = find_idx([‚Äúcodigo‚Äù, ‚Äúcode‚Äù])
idx_name = find_idx([‚Äúproducto‚Äù, ‚Äúdescripcion‚Äù, ‚Äúdescription‚Äù, ‚Äúnombre‚Äù, ‚Äúname‚Äù])
idx_usd = find_idx([‚Äúusd‚Äù, ‚Äúdolar‚Äù, ‚Äúprecio en dolares‚Äù])
idx_ars = find_idx([‚Äúars‚Äù, ‚Äúpesos‚Äù, ‚Äúprecio en pesos‚Äù])
exchange = get_exchange_rate()
catalog = []
for line in rows[1:]:
if not line:
continue
code = (line[idx_code].strip() if idx_code is not None and idx_code < len(line) else ‚Äú‚Äù)
name = (line[idx_name].strip() if idx_name is not None and idx_name < len(line) else ‚Äú‚Äù)
usd = to_decimal_money(line[idx_usd]) if idx_usd is not None and idx_usd < len(line) else Decimal(‚Äú0‚Äù)
ars = to_decimal_money(line[idx_ars]) if idx_ars is not None and idx_ars < len(line) else Decimal(‚Äú0‚Äù)
if ars == 0 and usd > 0:
ars = (usd * exchange).quantize(Decimal(‚Äú0.01‚Äù), rounding=ROUND_HALF_UP)
if name and (usd > 0 or ars > 0):
catalog.append({‚Äúcode‚Äù: code, ‚Äúname‚Äù: name, ‚Äúprice_usd‚Äù: float(usd), ‚Äúprice_ars‚Äù: float(ars)})
[logger.info](http://logger.info)(f‚Äùüì¶ Cat√°logo cargado: {len(catalog)} productos‚Äù)
return catalog
except Exception as e:
logger.error(f‚ÄùError cargando cat√°logo: {e}‚Äù, exc_info=True)
return []

def _build_faiss_index_from_catalog(catalog):
try:
if not catalog:
return None, 0
texts = [str(p.get(‚Äúname‚Äù, ‚Äú‚Äù)).strip() for p in catalog if str(p.get(‚Äúname‚Äù, ‚Äú‚Äù)).strip()]
if not texts:
return None, 0
vectors = []
batch = 512
for i in range(0, len(texts), batch):
chunk = texts[i:i + batch]
resp = client.embeddings.create(input=chunk, model=‚Äútext-embedding-3-small‚Äù, timeout=REQUESTS_TIMEOUT)
vectors.extend([d.embedding for d in resp.data])
if not vectors:
return None, 0
vecs = np.array(vectors).astype(‚Äúfloat32‚Äù)
if vecs.ndim != 2 or vecs.shape[0] == 0 or vecs.shape[1] == 0:
return None, 0
index = faiss.IndexFlatL2(vecs.shape[1])
index.add(vecs)
[logger.info](http://logger.info)(f‚Äù‚úÖ √çndice FAISS creado con {vecs.shape[0]} vectores‚Äù)
return index, vecs.shape[0]
except Exception as e:
logger.error(f‚ÄùError construyendo FAISS: {e}‚Äù, exc_info=True)
return None, 0

def get_catalog_and_index():
with _catalog_lock:
if _catalog_and_index_cache[‚Äúcatalog‚Äù] is not None:
return _catalog_and_index_cache[‚Äúcatalog‚Äù], _catalog_and_index_cache[‚Äúindex‚Äù]
catalog = load_catalog()
index, _ = _build_faiss_index_from_catalog(catalog)
_catalog_and_index_cache[‚Äúcatalog‚Äù] = catalog
_catalog_and_index_cache[‚Äúindex‚Äù] = index
_catalog_and_index_cache[‚Äúbuilt_at‚Äù] = datetime.utcnow().isoformat()
return catalog, index

[logger.info](http://logger.info)(‚Äú‚è≥ Precargando cat√°logo e √≠ndice FAISS‚Ä¶‚Äù)
_ = get_catalog_and_index()
[logger.info](http://logger.info)(‚Äú‚úÖ Cat√°logo precargado correctamente.‚Äù)

def fuzzy_search(query: str, limit: int = 20):
catalog, _ = get_catalog_and_index()
if not catalog:
return []
names = [p[‚Äúname‚Äù] for p in catalog]
matches = process.extract(query, names, scorer=fuzz.WRatio, limit=limit)
return [(catalog[i], score) for _, score, i in matches if score >= 60]

def semantic_search(query: str, top_k: int = 20):
catalog, index = get_catalog_and_index()
if not catalog or index is None or not query:
return []
try:
resp = client.embeddings.create(input=[query], model=‚Äútext-embedding-3-small‚Äù, timeout=REQUESTS_TIMEOUT)
emb = np.array([resp.data[0].embedding]).astype(‚Äúfloat32‚Äù)
D, I = index.search(emb, top_k)
results = []
for dist, idx in zip(D[0], I[0]):
if 0 <= idx < len(catalog):
score = 1.0 / (1.0 + float(dist))
results.append((catalog[idx], score))
return results
except Exception as e:
logger.error(f‚ÄùError en b√∫squeda sem√°ntica: {e}‚Äù)
return []

# ‚Üê ALIAS EXPANDIDOS PARA CUBIERTAS

SEARCH_ALIASES = {
‚Äúyama‚Äù: ‚Äúyamaha‚Äù, ‚Äúgilera‚Äù: ‚Äúgilera‚Äù, ‚Äúzan‚Äù: ‚Äúzanella‚Äù, ‚Äúhond‚Äù: ‚Äúhonda‚Äù,
‚Äúacrilico‚Äù: ‚Äúacrilico tablero‚Äù, ‚Äúaceite 2t‚Äù: ‚Äúaceite pride 2t‚Äù,
‚Äúaceite 4t‚Äù: ‚Äúaceite moto 4t‚Äù, ‚Äúaceite moto‚Äù: ‚Äúaceite‚Äù,
‚Äúvc‚Äù: ‚ÄúVC‚Äù, ‚Äúaf‚Äù: ‚ÄúAF‚Äù, ‚Äúnsu‚Äù: ‚ÄúNSU‚Äù, ‚Äúgulf‚Äù: ‚ÄúGULF‚Äù,
‚Äúyamalube‚Äù: ‚ÄúYAMALUBE‚Äù, ‚Äúsuzuki‚Äù: ‚Äúsuzuki‚Äù, ‚Äúzusuki‚Äù: ‚Äúsuzuki‚Äù,
‚Äúcubierta‚Äù: ‚Äúneumatico llanta‚Äù,
‚Äúcubiertas‚Äù: ‚Äúneumatico llanta‚Äù,
‚Äúneumatico‚Äù: ‚Äúcubierta llanta‚Äù,
‚Äúneumaticos‚Äù: ‚Äúcubierta llanta‚Äù,
‚Äúgoma‚Äù: ‚Äúcubierta neumatico‚Äù,
‚Äúgomas‚Äù: ‚Äúcubierta neumatico‚Äù
}

def normalize_search_query(query: str) -> str:
q = query.lower()
for alias, replacement in SEARCH_ALIASES.items():
if alias in q:
q = q.replace(alias, replacement)
return q

def hybrid_search(query: str, limit: int = 15):
query = normalize_search_query(query)
fuzzy = fuzzy_search(query, limit=limit*2)
sem = semantic_search(query, top_k=limit*2)
combined: Dict[str, Dict[str, Any]] = {}
for prod, s in fuzzy:
code = prod.get(‚Äúcode‚Äù, f‚Äùid_{id(prod)}‚Äù)
combined.setdefault(code, {‚Äúprod‚Äù: prod, ‚Äúfuzzy‚Äù: Decimal(0), ‚Äúsem‚Äù: Decimal(0)})
combined[code][‚Äúfuzzy‚Äù] = max(combined[code][‚Äúfuzzy‚Äù], Decimal(s)/Decimal(100))
for prod, s in sem:
code = prod.get(‚Äúcode‚Äù, f‚Äùid_{id(prod)}‚Äù)
combined.setdefault(code, {‚Äúprod‚Äù: prod, ‚Äúfuzzy‚Äù: Decimal(0), ‚Äúsem‚Äù: Decimal(0)})
combined[code][‚Äúsem‚Äù] = max(combined[code][‚Äúsem‚Äù], Decimal(str(s)))
out = []
for _, d in combined.items():
score = Decimal(‚Äú0.6‚Äù)*d[‚Äúsem‚Äù] + Decimal(‚Äú0.4‚Äù)*d[‚Äúfuzzy‚Äù]
out.append((d[‚Äúprod‚Äù], score))
out.sort(key=lambda x: x[1], reverse=True)
return [p for p, _ in out[:limit]]

# ‚Üê B√öSQUEDA MULTI-SIN√ìNIMO

def smart_search_with_synonyms(query: str, limit: int = 15):
‚Äú‚Äù‚ÄúB√∫squeda inteligente que prueba sin√≥nimos autom√°ticamente‚Äù‚Äù‚Äù
synonym_groups = {
‚Äúcubierta‚Äù: [‚Äúcubierta‚Äù, ‚Äúneumatico‚Äù, ‚Äúllanta‚Äù, ‚Äúgoma‚Äù],
‚Äúaceite‚Äù: [‚Äúaceite‚Äù, ‚Äúlubricante‚Äù],
‚Äúfiltro‚Äù: [‚Äúfiltro‚Äù],
‚Äúbujia‚Äù: [‚Äúbujia‚Äù, ‚Äúbuj√≠as‚Äù],
}

```
query_lower = query.lower()
queries_to_try = [query]

for main_term, synonyms in synonym_groups.items():
    if main_term in query_lower:
        for syn in synonyms:
            alt_query = query_lower.replace(main_term, syn)
            if alt_query != query_lower:
                queries_to_try.append(alt_query)
        break

all_results = {}
for q in queries_to_try[:3]:
    results = hybrid_search(q, limit=limit*2)
    for prod in results:
        code = prod["code"]
        if code not in all_results:
            all_results[code] = prod

return list(all_results.values())[:limit]
```

def cart_add(phone: str, code: str, qty: int, name: str, price_ars: Decimal, price_usd: Decimal):
qty = max(1, min(int(qty or 1), 1000))
price_ars = price_ars.quantize(Decimal(‚Äú0.01‚Äù))
price_usd = price_usd.quantize(Decimal(‚Äú0.01‚Äù))
with cart_lock, get_db_connection() as conn:
cur = conn.cursor()
cur.execute(‚ÄúSELECT quantity FROM carts WHERE phone=? AND code=?‚Äù, (phone, code))
row = cur.fetchone()
now = datetime.now().isoformat()
if row:
new_qty = int(row[0]) + qty
cur.execute(‚ÄúUPDATE carts SET quantity=?, created_at=? WHERE phone=? AND code=?‚Äù, (new_qty, now, phone, code))
else:
cur.execute(‚ÄúINSERT INTO carts (phone, code, quantity, name, price_ars, price_usd, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)‚Äù, (phone, code, qty, name, str(price_ars), str(price_usd), now))

def cart_get(phone: str, max_age_hours: int = 24):
with get_db_connection() as conn:
cur = conn.cursor()
cutoff = (datetime.now() - timedelta(hours=max_age_hours)).isoformat()
cur.execute(‚ÄúDELETE FROM carts WHERE phone=? AND created_at < ?‚Äù, (phone, cutoff))
cur.execute(‚ÄúSELECT code, quantity, name, price_ars FROM carts WHERE phone=?‚Äù, (phone,))
rows = cur.fetchall()
out = []
for r in rows:
code, q, name, price_str = r[0], int(r[1]), r[2], r[3]
try:
price_dec = Decimal(price_str)
except (InvalidOperation, TypeError):
price_dec = Decimal(‚Äú0.00‚Äù)
out.append((code, q, name, price_dec))
return out

def cart_update_qty(phone: str, code: str, qty: int):
qty = max(0, min(int(qty or 0), 999999))
with cart_lock, get_db_connection() as conn:
if qty == 0:
conn.execute(‚ÄúDELETE FROM carts WHERE phone=? AND code=?‚Äù, (phone, code))
else:
now = datetime.now().isoformat()
conn.execute(‚ÄúUPDATE carts SET quantity=?, created_at=? WHERE phone=? AND code=?‚Äù, (qty, now, phone, code))

def cart_clear(phone: str):
with cart_lock, get_db_connection() as conn:
conn.execute(‚ÄúDELETE FROM carts WHERE phone=?‚Äù, (phone,))

def cart_totals(phone: str) -> Tuple[Decimal, Decimal]:
items = cart_get(phone)
total = sum(q * price for _, q, __, price in items)
discount = Decimal(‚Äú0.05‚Äù) * total if total > Decimal(‚Äú10000000‚Äù) else Decimal(‚Äú0.00‚Äù)
final = (total - discount).quantize(Decimal(‚Äú0.01‚Äù))
return final, discount.quantize(Decimal(‚Äú0.01‚Äù))

def parse_bulk_list(text: str) -> List[Tuple[int, str]]:
text = text.replace(‚Äù,‚Äù, ‚Äú\n‚Äù).replace(‚Äù;‚Äù, ‚Äú\n‚Äù)
lines = text.strip().split(‚Äù\n‚Äù)
parsed = []
for line in lines:
line = line.strip()
if not line:
continue
match = re.match(r‚Äô^(\d+)\s+(.+)$‚Äô, line)
if match:
qty = int(match.group(1))
product_name = match.group(2).strip()
parsed.append((qty, product_name))
else:
parsed.append((1, line))
return parsed

def is_bulk_list_request(text: str) -> bool:
if not text:
return False
lower = text.lower()
norm = text.replace(‚Äù,‚Äù, ‚Äú\n‚Äù).replace(‚Äù;‚Äù, ‚Äú\n‚Äù)
lines = [l for l in norm.split(‚Äù\n‚Äù) if l.strip()]
lines_with_qty = sum(1 for l in lines if re.match(r‚Äô^\d+\s+\w‚Äô, l.strip()))
has_quote_intent = any(kw in lower for kw in [‚Äúcotiz‚Äù, ‚Äúprecio‚Äù, ‚Äúcuanto‚Äù, ‚Äútenes‚Äù, ‚Äústock‚Äù, ‚Äúpedido‚Äù, ‚Äúlista‚Äù])
is_multiline = len(lines) >= 3
return (lines_with_qty >= 3) or (has_quote_intent and is_multiline and lines_with_qty >= 1)

def _format_list(products, max_items=15) -> str:
if not products:
return ‚ÄúNo encontr√© productos.‚Äù
lines = []
for p in products[:max_items]:
code = p.get(‚Äúcode‚Äù, ‚Äú‚Äù).strip() or ‚Äús/c‚Äù
name = p.get(‚Äúname‚Äù, ‚Äú‚Äù).strip()
ars = Decimal(str(p.get(‚Äúprice_ars‚Äù, 0))).quantize(Decimal(‚Äú0.01‚Äù))
lines.append(f‚Äù‚Ä¢ **(C√≥d: {code})** {name} - ${ars:,.0f} ARS‚Äù)
return ‚Äú\n‚Äù.join(lines)

def _format_bulk_quote_response(data: Dict) -> str:
if not data.get(‚Äúsuccess‚Äù):
return ‚ÄúNo pude procesar la lista. Prob√° reenviarla en l√≠neas separadas.‚Äù
results = data.get(‚Äúresults‚Äù, [])
not_found = data.get(‚Äúnot_found‚Äù, [])
total = Decimal(str(data.get(‚Äútotal_quoted‚Äù, 0)))
lines = [‚Äúüìã *COTIZACI√ìN DE TU LISTA:*\n‚Äù]
if results:
lines.append(f‚Äù‚úÖ *Encontr√© {len(results)} productos:*\n‚Äù)
for item in results:
qty = item[‚Äúquantity‚Äù]
name = item[‚Äúfound‚Äù]
code = item[‚Äúcode‚Äù]
price = Decimal(str(item[‚Äúprice_unit‚Äù]))
subtotal = Decimal(str(item[‚Äúsubtotal‚Äù]))
lines.append(f‚Äù‚Ä¢ {qty} √ó *{name}*‚Äù)
lines.append(f‚Äù  (C√≥d: {code}) - ${price:,.0f} c/u = ${subtotal:,.0f}‚Äù)
lines.append(f‚Äù\nüí∞ *TOTAL: ${total:,.2f} ARS*‚Äù)
if not_found:
lines.append(f‚Äù\n‚ö†Ô∏è *No encontr√© {len(not_found)} productos:*‚Äù)
for item in not_found[:5]:
lines.append(f‚Äù‚Ä¢ {item[‚Äòquantity‚Äô]} √ó {item[‚Äòrequested‚Äô]}‚Äù)
if len(not_found) > 5:
lines.append(f‚Äù‚Ä¶ y {len(not_found) - 5} m√°s‚Äù)
lines.append(‚Äù\n¬øQuer√©s que los agregue al carrito? üõí Decime: *dale* o *agregalos*.‚Äù)
return ‚Äú\n‚Äù.join(lines)

class ToolExecutor:
def **init**(self, phone: str):
self.phone = phone

```
def execute(self, tool_name: str, arguments: Any) -> Dict[str, Any]:
    method = getattr(self, tool_name, None)
    if not method:
        return {"error": f"Tool '{tool_name}' no encontrada"}
    if tool_name == "quote_bulk_list":
        if isinstance(arguments, str):
            arguments = {"raw_list": arguments}
        elif isinstance(arguments, dict):
            if "raw_list" in arguments and isinstance(arguments["raw_list"], str):
                pass
            elif "text" in arguments and isinstance(arguments["text"], str):
                arguments = {"raw_list": arguments["text"]}
            elif "list" in arguments:
                if isinstance(arguments["list"], list):
                    arguments = {"raw_list": "\n".join([str(x) for x in arguments["list"]])}
                elif isinstance(arguments["list"], str):
                    arguments = {"raw_list": arguments["list"]}
                else:
                    arguments = {"raw_list": str(arguments["list"])}
            elif len(arguments) == 1:
                only_key = next(iter(arguments.keys()))
                if isinstance(only_key, str) and len(only_key) >= 20:
                    arguments = {"raw_list": only_key}
                else:
                    arguments = {"raw_list": str(arguments)}
            else:
                arguments = {"raw_list": json.dumps(arguments, ensure_ascii=False)}
        else:
            arguments = {"raw_list": str(arguments)}
    try:
        logger.info(f"üîß Ejecutando tool: {tool_name} con args: {list(arguments.keys()) if isinstance(arguments, dict) else type(arguments)}")
        return method(**arguments) if isinstance(arguments, dict) else method(arguments)
    except TypeError as e:
        logger.error(f"‚ùå Error en {tool_name}: {e}", exc_info=True)
        return {"error": f"Argumentos inv√°lidos para {tool_name}: {e}"}
    except Exception as e:
        logger.error(f"‚ùå Error inesperado en {tool_name}: {e}", exc_info=True)
        return {"error": str(e)}

def search_products(self, query: str, limit: int = 15) -> Dict[str, Any]:
    results = smart_search_with_synonyms(query, limit=limit)  # ‚Üê USA LA NUEVA FUNCI√ìN
    if results:
        save_user_state(self.phone, results[0])
        save_last_search(self.phone, [
            {"code": p["code"], "name": p["name"], "price_ars": p["price_ars"], "price_usd": p["price_usd"], "qty": 1}
            for p in results
        ], query)
    return {
        "success": True,
        "query": query,
        "results": [
            {"code": p["code"], "name": p["name"], "price_ars": p["price_ars"], "price_usd": p["price_usd"], "qty": 1}
            for p in results
        ],
        "count": len(results)
    }

def add_to_cart(self, items: List[Dict]) -> Dict[str, Any]:
    catalog, _ = get_catalog_and_index()
    added, not_found = [], []
    for item in items:
        code = str(item.get("code", "")).strip()
        qty = int(item.get("quantity", 1))
        ok, norm = validate_tercom_code(code)
        if not ok:
            not_found.append(code)
            continue
        prod = next((x for x in catalog if x["code"] == norm), None)
        if prod:
            price_ars = to_decimal_money(prod["price_ars"])
            price_usd = to_decimal_money(prod["price_usd"])
            cart_add(self.phone, norm, qty, prod["name"], price_ars, price_usd)
            added.append({"code": norm, "name": prod["name"], "quantity": qty, "subtotal": float((price_ars * qty).quantize(Decimal("0.01")))})
        else:
            not_found.append(code)
    total_added = sum(a["subtotal"] for a in added) if added else 0.0
    return {"success": bool(added), "added": added, "not_found": not_found, "total_added": total_added}

def view_cart(self) -> Dict[str, Any]:
    items = cart_get(self.phone)
    total, discount = cart_totals(self.phone)
    return {
        "success": True,
        "items": [{"code": c, "name": n, "quantity": q, "price_unit": float(p), "price_total": float((p * q).quantize(Decimal("0.01")))} for c, q, n, p in items],
        "total": float(total),
        "discount": float(discount),
        "item_count": len(items)
    }

def update_cart_item(self, code: str, quantity: int) -> Dict[str, Any]:
    cart_update_qty(self.phone, code, quantity)
    return {"success": True, "message": "Actualizado"}

def clear_cart(self) -> Dict[str, Any]:
    cart_clear(self.phone)
    return {"success": True}

def confirm_order(self) -> Dict[str, Any]:
    items = cart_get(self.phone)
    if not items:
        return {"success": False, "error": "Carrito vac√≠o"}
    total, _ = cart_totals(self.phone)
    cart_clear(self.phone)
    return {"success": True, "message": f"Pedido confirmado por ${total:,.2f} ARS"}

def get_last_search_results(self) -> Dict[str, Any]:
    search = get_last_search(self.phone)
    if not search:
        return {"success": False}
    return {"success": True, "query": search["query"], "products": search["products"], "product_codes": [p["code"] for p in search["products"]]}

def quote_bulk_list(self, raw_list: str) -> Dict[str, Any]:
    catalog, _ = get_catalog_and_index()
    parsed_items = parse_bulk_list(raw_list)
    if not parsed_items:
        return {"success": False, "error": "No pude interpretar la lista"}
    results, not_found = [], []
    total_quoted = Decimal("0")
    for requested_qty, product_name in parsed_items:
        matches = hybrid_search(product_name, limit=3)
        if matches:
            best = matches[0]
            price_ars = Decimal(str(best["price_ars"])).quantize(Decimal("0.01"))
            subtotal = (price_ars * requested_qty).quantize(Decimal("0.01"))
            total_quoted += subtotal
            results.append({"requested": product_name, "found": best["name"], "code": best["code"], "quantity": requested_qty, "price_unit": float(price_ars), "subtotal": float(subtotal)})
        else:
            not_found.append({"requested": product_name, "quantity": requested_qty})
    return {"success": True, "found_count": len(results), "not_found_count": len(not_found), "results": results, "not_found": not_found, "total_quoted": float(total_quoted), "message": f"Encontr√© {len(results)} de {len(parsed_items)} productos solicitados"}
```

BULK_CONFIRM_TRIGGERS = [‚Äúdale‚Äù, ‚Äúagregalos‚Äù, ‚Äúagreg√°‚Äù, ‚Äúagrega‚Äù, ‚Äúsumalos‚Äù, ‚Äúsum√°‚Äù, ‚Äúok‚Äù, ‚Äúsi‚Äù, ‚Äús√≠‚Äù, ‚Äúperfecto‚Äù, ‚Äúmetelos‚Äù]

def _intent_needs_basics(user_message: str) -> bool:
t = user_message.lower()
triggers = [‚Äúsurtido‚Äù, ‚Äúb√°sico‚Äù, ‚Äúbasico‚Äù, ‚Äúabrir mi local‚Äù, ‚Äúrecomendar‚Äù, ‚Äúproponer‚Äù, ‚Äúlista de productos‚Äù, ‚Äúlo b√°sico‚Äù, ‚Äúlo basico‚Äù, ‚Äúcatalogo‚Äù, ‚Äúcat√°logo‚Äù, ‚Äúempezar‚Äù, ‚Äúcomenzar‚Äù, ‚Äúinicial‚Äù, ‚Äúnecesito productos‚Äù]
return any(x in t for x in triggers)

def _force_search_and_reply(phone: str, query: str) -> str:
results = hybrid_search(query, limit=15)
if not results:
results = hybrid_search(‚Äúrepuestos basicos moto‚Äù, limit=15)
if not results:
return ‚ÄúDisculp√°, tengo problemas con el cat√°logo.‚Äù
save_last_search(phone, [{‚Äúcode‚Äù: p[‚Äúcode‚Äù], ‚Äúname‚Äù: p[‚Äúname‚Äù], ‚Äúprice_ars‚Äù: p[‚Äúprice_ars‚Äù], ‚Äúprice_usd‚Äù: p[‚Äúprice_usd‚Äù], ‚Äúqty‚Äù: 1} for p in results], query)
save_user_state(phone, results[0])
listado = _format_list(results, max_items=len(results))
return f‚ÄùAc√° ten√©s {len(results)} productos sugeridos:\n\n{listado}\n\n¬øQuer√©s que agregue alguno?‚Äù

def _add_last_search_to_cart(phone: str) -> str:
last = get_last_search(phone)
if not last or not last.get(‚Äúproducts‚Äù):
return ‚ÄúNo tengo productos recientes para agregar.‚Äù
items = []
for p in last[‚Äúproducts‚Äù]:
items.append({‚Äúcode‚Äù: p[‚Äúcode‚Äù], ‚Äúquantity‚Äù: int(p.get(‚Äúqty‚Äù, 1))})
executor = ToolExecutor(phone)
result = executor.add_to_cart(items)
if result.get(‚Äúsuccess‚Äù):
total = result.get(‚Äútotal_added‚Äù, 0.0)
return f‚Äùüõí Agregu√© {len(result[‚Äòadded‚Äô])} √≠tems al carrito por ${total:,.0f} ARS.‚Äù
return ‚ÄúNo pude agregar los productos al carrito.‚Äù

def run_agent(phone: str, user_message: str, max_iterations: int = 8) -> str:
catalog, _ = get_catalog_and_index()
if not catalog:
return ‚ÄúNo puedo acceder al cat√°logo.‚Äù
if is_bulk_list_request(user_message):
[logger.info](http://logger.info)(f‚Äùüîç Lista masiva detectada para {phone}‚Äù)
executor = ToolExecutor(phone)
result = executor.quote_bulk_list(user_message)
if result.get(‚Äúsuccess‚Äù) and result.get(‚Äúresults‚Äù):
products_for_save = [{‚Äúcode‚Äù: r[‚Äúcode‚Äù], ‚Äúname‚Äù: r[‚Äúfound‚Äù], ‚Äúprice_ars‚Äù: r[‚Äúprice_unit‚Äù], ‚Äúprice_usd‚Äù: float(Decimal(str(r[‚Äúprice_unit‚Äù])) / DEFAULT_EXCHANGE), ‚Äúqty‚Äù: int(r[‚Äúquantity‚Äù])} for r in result[‚Äúresults‚Äù]]
save_last_search(phone, products_for_save, ‚ÄúLista masiva‚Äù)
return _format_bulk_quote_response(result)
lower = user_message.lower().strip()
if any(trig == lower or trig in lower for trig in BULK_CONFIRM_TRIGGERS):
return _add_last_search_to_cart(phone)
executor = ToolExecutor(phone)
history = get_history_today(phone, limit=20)
[logger.info](http://logger.info)(f‚Äùüì± {phone}: {user_message[:200]}‚Äù)

```
# ‚Üê PROMPT ACTUALIZADO
system_prompt = """Sos Fran, vendedor de Tercom (mayorista de repuestos de motos en Argentina).
```

REGLAS CR√çTICAS:

1. Si el usuario env√≠a una LISTA CON CANTIDADES (ej: ‚Äò10 BUJIA NGK‚Äô), ejecut√° quote_bulk_list con todo el texto.
1. Si pide ‚Äúsurtido/b√°sico/cat√°logo‚Äù, ejecut√° search_products primero.
1. Antes de decir que agregaste algo, ejecut√° add_to_cart. Para ver: view_cart. Para confirmar: confirm_order.
1. Mostr√° precios en ARS formateados y c√≥digos en formato (C√≥d: 1234/12345-123).
1. Respond√© como humano argentino (us√° ‚Äòvos‚Äô, ‚Äòdale‚Äô, ‚Äòche‚Äô, ‚Äòmir√°‚Äô).
1. **IMPORTANTE CUBIERTAS: Si el usuario pide ‚Äúcubiertas/neum√°ticos/llantas/gomas‚Äù, ejecut√° search_products con el modelo de moto (ej: ‚Äúcubierta honda wave‚Äù). El sistema ya busca sin√≥nimos autom√°ticamente.**
1. Si no encontr√°s resultados, ofrec√© buscar con t√©rminos alternativos o pregunt√° por m√°s detalles (medida, modelo, etc).

Formato de productos:
‚Ä¢ **(C√≥d: XXXX/XXXXX-XXX)** Nombre - $precio ARS‚Äù‚Äù‚Äù

```
messages = [{"role": "system", "content": system_prompt}]
for row in history:
    messages.append({"role": row["role"], "content": row["message"]})
messages.append({"role": "user", "content": user_message})

tools = [
    {"type": "function", "function": {"name": "search_products"}},
    {"type": "function", "function": {"name": "add_to_cart"}},
    {"type": "function", "function": {"name": "view_cart"}},
    {"type": "function", "function": {"name": "update_cart_item"}},
    {"type": "function", "function": {"name": "confirm_order"}},
    {"type": "function", "function": {"name": "quote_bulk_list"}},
    {"type": "function", "function": {"name": "get_last_search_results"}}
]

last_text = ""
for _ in range(max_iterations):
    try:
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            tools=tools,
            tool_choice="auto",
            temperature=0.6,
            max_tokens=2000,
            timeout=REQUESTS_TIMEOUT
        )
        message = response.choices[0].message
        if getattr(message, "tool_calls", None):
            messages.append({"role": "assistant", "content": message.content or "", "tool_calls": message.tool_calls})
            for tc in message.tool_calls:
                args = {}
                try:
                    args = json.loads(tc.function.arguments or "{}")
                except Exception:
                    args = tc.function.arguments or {}
                result = executor.execute(tc.function.name, args)
                if tc.function.name == "quote_bulk_list":
                    if result.get("success") and result.get("results"):
                        products_for_save = [{"code": r["code"], "name": r["found"], "price_ars": r["price_unit"], "price_usd": float(Decimal(str(r["price_unit"])) / DEFAULT_EXCHANGE), "qty": int(r["quantity"])} for r in result["results"]]
                        save_last_search(phone, products_for_save, "Lista masiva")
                    text = _format_bulk_quote_response(result)
                    save_message(phone, text, "assistant")
                    return text
                messages.append({"role": "tool", "tool_call_id": tc.id, "name": tc.function.name, "content": json.dumps(result, ensure_ascii=False)})
            continue
        final_response = (message.content or "").strip()
        last_text = final_response
        if _intent_needs_basics(user_message):
            has_codes = bool(re.search(r"\(C√≥d:\s*\d{4}/\d{5}-\d{3}\)", final_response))
            if not has_codes:
                return _force_search_and_reply(phone, "surtido basico repuestos moto")
        if final_response:
            return final_response
        messages.append({"role": "system", "content": "Respond√© con una frase clara."})
    except Exception as e:
        logger.error(f"‚ùå run_agent loop: {e}", exc_info=True)
        return "Disculp√°, hubo un problema. Prob√° de nuevo."
return last_text or _force_search_and_reply(phone, "surtido basico")
```

@app.before_request
def validate_twilio_signature():
if request.path == ‚Äú/webhook‚Äù and twilio_validator:
signature = request.headers.get(‚ÄúX-Twilio-Signature‚Äù, ‚Äú‚Äù)
try:
form_data = request.form.to_dict()
except Exception:
form_data = {}
valid = twilio_validator.validate(request.url, form_data, signature)
if not valid:
return Response(‚ÄúInvalid signature‚Äù, status=403)

@app.route(‚Äù/webhook‚Äù, methods=[‚ÄúPOST‚Äù])
def webhook():
try:
msg_in = (request.values.get(‚ÄúBody‚Äù, ‚Äú‚Äù) or ‚Äú‚Äù).strip()
phone = request.values.get(‚ÄúFrom‚Äù, ‚Äú‚Äù)
if not rate_limit_check(phone):
resp = MessagingResponse()
resp.message(‚ÄúEsper√° un momento üòä‚Äù)
return str(resp)
save_message(phone, msg_in, ‚Äúuser‚Äù)
text = run_agent(phone, msg_in)
save_message(phone, text, ‚Äúassistant‚Äù)
resp = MessagingResponse()
resp.message(text)
return str(resp)
except Exception as e:
logger.error(f‚Äù‚ùå Webhook: {e}‚Äù, exc_info=True)
resp = MessagingResponse()
resp.message(‚ÄúDisculp√°, hubo un problema t√©cnico.‚Äù)
return str(resp)

# ‚Üê ENDPOINT DEBUG PARA VERIFICAR B√öSQUEDAS

@app.route(‚Äù/debug/search/<query>‚Äù, methods=[‚ÄúGET‚Äù])
def debug_search(query: str):
‚Äú‚Äù‚ÄúEndpoint temporal para debugging de b√∫squedas‚Äù‚Äù‚Äù
catalog, _ = get_catalog_and_index()
matches = [p for p in catalog if query.lower() in p[‚Äúname‚Äù].lower()]
hybrid = hybrid_search(query, limit=10)
smart = smart_search_with_synonyms(query, limit=10)
return jsonify({
‚Äúquery‚Äù: query,
‚Äúdirect_matches‚Äù: len(matches),
‚Äúdirect_samples‚Äù: matches[:5],
‚Äúhybrid_results‚Äù: [{‚Äúname‚Äù: p[‚Äúname‚Äù], ‚Äúcode‚Äù: p[‚Äúcode‚Äù]} for p in hybrid],
‚Äúsmart_synonym_results‚Äù: [{‚Äúname‚Äù: p[‚Äúname‚Äù], ‚Äúcode‚Äù: p[‚Äúcode‚Äù]} for p in smart]
})

@app.route(‚Äù/health‚Äù, methods=[‚ÄúGET‚Äù])
def health():
try:
catalog, index = get_catalog_and_index()
return jsonify({‚Äústatus‚Äù: ‚Äúok‚Äù, ‚Äúversion‚Äù: ‚Äú2.6-cubierta-fix‚Äù, ‚Äúproducts‚Äù: len(catalog) if catalog else 0, ‚Äúfaiss‚Äù: bool(index)})
except Exception as e:
return jsonify({‚Äústatus‚Äù: ‚Äúerror‚Äù, ‚Äúmsg‚Äù: str(e)}), 500

if **name** == ‚Äú**main**‚Äù:
[logger.info](http://logger.info)(‚ÄúüöÄ Iniciando Fran 2.6 con fix de cubiertas‚Äù)
port = int(os.environ.get(‚ÄúPORT‚Äù, 5000))
app.run(host=‚Äú0.0.0.0‚Äù, port=port, debug=False)
</file_text>
</create_file>

-----
